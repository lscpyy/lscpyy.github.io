<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="系统级I&#x2F;O">
<meta property="og:url" content="http://example.com/2022/03/04/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:published_time" content="2022-03-04T11:39:43.000Z">
<meta property="article:modified_time" content="2022-03-04T11:41:27.679Z">
<meta property="article:author" content="LSC">
<meta property="article:tag" content="hexo">
<meta property="article:tag" content="csapp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/03/04/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>系统级I/O | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/5.jpg">
      <meta itemprop="name" content="LSC">
      <meta itemprop="description" content="个人技术分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          系统级I/O
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-04 19:39:43 / Modified: 19:41:27" itemprop="dateCreated datePublished" datetime="2022-03-04T19:39:43+08:00">2022-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h1><p> 输入/输出（I/O)是在主存和外部设备(例如磁盘驱动器、终端和网络)之间复制数据的过 程。输人操作是从 I/O 设备复制数据到主存，而输出操作是从主存复制数据到 I/O设备。 </p>
<h1 id="学习-Unix-I-O意义-："><a href="#学习-Unix-I-O意义-：" class="headerlink" title="学习 Unix I/O意义 ："></a>学习 Unix I/O意义 ：</h1><h2 id="了解-Unix-I-O-将帮助你理解其他的系统概念。"><a href="#了解-Unix-I-O-将帮助你理解其他的系统概念。" class="headerlink" title="了解 Unix I/O 将帮助你理解其他的系统概念。"></a>了解 Unix I/O 将帮助你理解其他的系统概念。</h2><h2 id="有时你除了使用-Unix-I-O-以外别无选择。"><a href="#有时你除了使用-Unix-I-O-以外别无选择。" class="headerlink" title="有时你除了使用 Unix I/O 以外别无选择。"></a>有时你除了使用 Unix I/O 以外别无选择。</h2><p>标准 I/O 库没有提供读取文件元数据的方式，例如文件大小或文件创建时间。另外，I/O 库还存在一些问题，使得用它来进行网络编程非常冒险。 </p>
<h1 id="Unix-I-O-："><a href="#Unix-I-O-：" class="headerlink" title="Unix I/O ："></a>Unix I/O ：</h1><h4 id="所有的-I-O-设备-例如网络、磁盘和终端-都被模型化为文件，而所有的输入和输出都被当-作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许-Linux-内核引-出一个简单、低级的应用接口，称为-Unix-I-O-这使得所有的输人和输出都能以一种统-一且一致的方式来执行："><a href="#所有的-I-O-设备-例如网络、磁盘和终端-都被模型化为文件，而所有的输入和输出都被当-作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许-Linux-内核引-出一个简单、低级的应用接口，称为-Unix-I-O-这使得所有的输人和输出都能以一种统-一且一致的方式来执行：" class="headerlink" title="所有的 I/O 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I/O, 这使得所有的输人和输出都能以一种统 一且一致的方式来执行："></a>所有的 I/O 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I/O, 这使得所有的输人和输出都能以一种统 一且一致的方式来执行：</h4><p> 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操 作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这 个描述符。 </p>
<p>Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准 输出（描述符为 1)和标准错误(描述符为 2)h头文件&lt; unistd.h&gt; 定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_ETLENO，它们可用来代替显式的描述符值。 </p>
<p>改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为 0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek 操 作，显式地设置文件的当前位置为是。 </p>
<p>读写文件。一个读操作就是从文件复制 n&gt;0 个字节到内存，从当前文件位置是开 始，然后将k增加到k+n。给定一个大小为讲字节的文件，当时执行读操作 会触发一个称为 end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结 尾处并没有明确的 “EOF 符号”。 类似地，写操作就是从内存复制 n&gt;0 个字节到一个文件，从当前文件位置k开始，然后更新k。</p>
<p> 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响 应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池 中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们 的内存资源。  </p>
<h1 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h1><h2 id="普通文件-：-文本文件和二进制文件"><a href="#普通文件-：-文本文件和二进制文件" class="headerlink" title="普通文件 ： 文本文件和二进制文件"></a>普通文件 ： 文本文件和二进制文件</h2><h3 id="文本文件："><a href="#文本文件：" class="headerlink" title="文本文件："></a>文本文件：</h3><p>文本文件是只含有 ASCII 或 Unicode 字符的普通文件 </p>
<h3 id="二进制文件："><a href="#二进制文件：" class="headerlink" title="二进制文件："></a>二进制文件：</h3><p> 所有其他的文件 </p>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p>目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件 </p>
<h1 id="打开和关闭文件-："><a href="#打开和关闭文件-：" class="headerlink" title="打开和关闭文件 ："></a>打开和关闭文件 ：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int open(char *filename, int flags, mode_t mode) </span><br><span class="line">							返回：若成功则为新文件描述符，若出错为一1。</span><br></pre></td></tr></table></figure>

<p> open 函数将 filename 转换为一个文件描述符，并且返回描述符数字。返回的描述符总 是在进程中当前没有打开的最小描述符。 </p>
<h3 id="flags："><a href="#flags：" class="headerlink" title="flags："></a>flags：</h3><p> O_RDONLY：只读。 O_WRONLY: 只写。 O_RDWR：可读可写 </p>
<p> O_CREAT：如果文件不存在，就创建它的一个截断的(空）文件。</p>
<p> O_TRUNC：如果文件已经存在，就截断它。</p>
<p>O_APPEND：在每次写操作前，设置文件位置到文件的结尾处。  </p>
<h3 id="mode-参数指定了新文件的访问权限位"><a href="#mode-参数指定了新文件的访问权限位" class="headerlink" title="mode 参数指定了新文件的访问权限位:"></a>mode 参数指定了新文件的访问权限位:</h3><p>作为上下文的一部分，每个进程都有一个 umask, 它是通过调用 umask 函数来设置 的。当进程通过带某个 mode 参数的 open 函数调用来创建一个新文件时，文件的访问权 限位被设置为 mode &amp; ~ umask 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);</span><br><span class="line">		返 回：若 成 功 则 为 0, 若 出 错 则 为-1。</span><br></pre></td></tr></table></figure>

<p> 进程通过调用 close 函数关闭一个打开的文件。 </p>
<h1 id="读-和-写-文-件"><a href="#读-和-写-文-件" class="headerlink" title="读 和 写 文 件 :"></a>读 和 写 文 件 :</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd, void *buf, size_t n);</span><br><span class="line">			返 回：若 成 功 则 为 读 的 字 节 数，若 EOF 则 为 0, 若 出 错 为 一1。</span><br><span class="line">ssize t write(int fd, const void *buf, size_t n);</span><br><span class="line">			返 回：若 成 功 則 为 写 的 字 节 数，若 出 错 则 为 一1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 过调用 lseek 函数，应用程序能够显示地修改当前文件的位置 </p>
<p>文件从当前文件位置开始只含有 20 多个字节，而我们以 50 个字节的片进行读取。这样一来，下一个 read 返回的不足 值为 20 . 此后的 read 将通过返回不足值 0 来发出 EOF 信号。  </p>
<p>从终端读文本行。如果打开文件是与终端相关联的（如键盘和显示器），那么每个 read 函数将一次传送一个文本行，返回的不足值等于文本行的大小。  </p>
<h1 id="用-RIO-包健壮地读写"><a href="#用-RIO-包健壮地读写" class="headerlink" title="用 RIO 包健壮地读写:"></a>用 RIO 包健壮地读写:</h1><h3 id="像网络程序这样容易出现不足值的应用中，RIO-包提供了方便、健壮和高效的-I-O。RIO-提供了两类不同的函数："><a href="#像网络程序这样容易出现不足值的应用中，RIO-包提供了方便、健壮和高效的-I-O。RIO-提供了两类不同的函数：" class="headerlink" title="像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O。RIO 提供了两类不同的函数："></a>像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O。RIO 提供了两类不同的函数：</h3><p>无缓冲的输入输出函数。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。</p>
<p>带缓冲的输入函数。这些函数允许你高效地从文件中读取文本行和二进制数据，这 些文件的内容缓存在应用级缓冲区内，类似于为printf 这样的标准 I/O函数提供 的缓冲区。带缓冲的RIO输人函数是线 程安全的，它在同一个描述符上可以被交错地调用。例如，你可以从一 个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。 </p>
<h2 id="RIO-的无缓冲的输入输出函数-："><a href="#RIO-的无缓冲的输入输出函数-：" class="headerlink" title="RIO 的无缓冲的输入输出函数 ："></a>RIO 的无缓冲的输入输出函数 ：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssize t rio_readn(int fd, void *usrbuf，size_t n);</span><br><span class="line">ssize_t rio_writen(int fd, void *usrbuf, size_t n);</span><br><span class="line">		返回：若成功则为传送的字节数，若 EOF 则为 0(只对 rio_reacin 而言），若出错则为一1。</span><br></pre></td></tr></table></figure>

<p> rio_read 函数在遇 到 EOF 时只能返回一个不足值。rio_writen 函数决不会返回不足值。 </p>
<p>对同一个描述符， 可以任意交错地调用 rio_readn 和 rio_writen。</p>
<p>如果 rio_readn 和 rio_ writen 函数被一个从应用信号处理程序的返回中断，那么每个函数都会手动地重启 read 或 write。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ssize_t rio_readn(int fd, void *usrbuf, size_t n)</span><br><span class="line"> &#123;</span><br><span class="line"> 	size_t nleft = n;</span><br><span class="line"> 	ssize_t nread;</span><br><span class="line"> 	char *bufp = usrbuf;</span><br><span class="line"></span><br><span class="line"> 	while (nleft &gt; 0)&#123;</span><br><span class="line"> 		if ((nread = read(fd, bufp, nleft))&lt; 0)&#123;</span><br><span class="line"> 			if (errno == EINTR)/* Interrupted by sig handler return */</span><br><span class="line">			 nread = 0; /* and call read()again */</span><br><span class="line"> 			else</span><br><span class="line"> 				return -1; / errno set by readO */</span><br><span class="line"> 		else if (nread == 0)</span><br><span class="line"> 			break; /* EOF */</span><br><span class="line"> 		nleft -= nread;</span><br><span class="line"> 		bufp += nread;</span><br><span class="line"> 	&#125;</span><br><span class="line"> return(n - nleft); /* Return &gt;= 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ssize t rio_writen(int fd, void *usrbuf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size t nleft = n;</span><br><span class="line">	ssize t nwritten;</span><br><span class="line">	char *bufp = usrbuf;</span><br><span class="line">	while(nleft &gt; 0)&#123;</span><br><span class="line">		if ((nwritten = write(fd, bufp, nleft))&lt;= 0)&#123;</span><br><span class="line">			if (errno == ENTRY)/* Interrupted by sig handler return */</span><br><span class="line">				nwritten = 0 /* and call write()again */</span><br><span class="line">			else</span><br><span class="line">				return -1;/* errno set by write()*/</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		bufp += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="RIO-的带缓冲的输入函数"><a href="#RIO-的带缓冲的输入函数" class="headerlink" title="RIO 的带缓冲的输入函数 :"></a>RIO 的带缓冲的输入函数 :</h2><p> 是调用一个包装函数（rio_readlineb), 它从一个内部读缓冲区复制一个 文本行，当缓冲区变空时，会自动地调用 read 重新填满缓冲区。对于既包含文本行也包含二 进制数据的文件，我们也提供了一个 rio_readn 带缓冲 区的版本，叫做 rio_readnb，它从和 rio_readlineb —样的读缓冲区中传送原始字节。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void rio_readinitb(rio_t *rp, int fd);</span><br><span class="line">										返 回： 无。</span><br><span class="line">ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);</span><br><span class="line">ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n):</span><br><span class="line">			返 回：若 成 功 则 为 读 的 字 节 数，若 EOF 则 为 0, 若 出 错 则 为 一1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 每打开一个描述符，都会调用一次 rio_readinitb 函数。它将描述符 fd 和地址 rp 处的一个类型为 rio_t 的读缓冲区联系起来。 </p>
<p> 对同一描述符，对 rio_readlineb 和 rio_readnb 的调用可以任意交叉进行。 </p>
<p> 对这些带缓冲的函数的 调用却不应和无缓冲的 rio_readn 函数交叉使用。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rio_readinitb(rio_t *rp, int fd)</span><br><span class="line"> &#123;</span><br><span class="line"> 	rp-&gt;rio_fd = fd;</span><br><span class="line"> 	rp-&gt;rio cnt = 0;</span><br><span class="line"> 	rp-&gt;rio—bufptr = rp-&gt;rio_buf;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ssize_t rio_readlineb(rio_t *rp，void *usrbuf, size t maxlen)</span><br><span class="line"> &#123;</span><br><span class="line"> 	int n, rc;</span><br><span class="line"> 	char c, *bufp = usrbuf;</span><br><span class="line"> 	for (n = 1; n &lt; maxlen; n++)&#123;</span><br><span class="line"> 		if ((rc = rio_read(rp, &amp;c, 1))== 1)&#123;</span><br><span class="line"> 			*bufp++ = c;</span><br><span class="line"> 			if (c == &#x27;\n&#x27;)&#123;</span><br><span class="line">				 n++;</span><br><span class="line"> 				break;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;else if (rc == 0)&#123;</span><br><span class="line"> 			if (n == 1)</span><br><span class="line">				 return 0; /* EOF, no data read */</span><br><span class="line"> 			else</span><br><span class="line">				 break; /* EOF, some data was read */</span><br><span class="line"> 		&#125;else</span><br><span class="line"> 			return -1; /* Error</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	*bufp = o；</span><br><span class="line"> 	return n-1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ssize t rio_readnb(rio_t *rp, void *usrbuf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft = n;</span><br><span class="line">	ssize_t nread;</span><br><span class="line">	char *bufp = usrbuf;</span><br><span class="line">	while (nleft &gt; 0)&#123;</span><br><span class="line">		if ((nread = rio_read(rp, bufp, nleft))&lt; 0)</span><br><span class="line">			return -1; /* errno set by read()*/</span><br><span class="line">		else if (nread == 0)</span><br><span class="line">			break; /* EOF */</span><br><span class="line">		nleft -= nread;</span><br><span class="line">	 bufp += nread;</span><br><span class="line">	&#125;</span><br><span class="line"> return (n - nleft); /* Return &gt;= 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读-取-文-件-元-数-据"><a href="#读-取-文-件-元-数-据" class="headerlink" title="读 取 文 件 元 数 据 :"></a>读 取 文 件 元 数 据 :</h1><p> 应用程序能够通过调用 stat 和 fstat 函数，检索到关于文件的信息（有时也称为文 件的元数据 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *filename, struct stat *buf);</span><br><span class="line">int fstat(int fd, struct stat *buf);</span><br><span class="line">					返回：若成功则为 0，若出错则为 _1。</span><br></pre></td></tr></table></figure>

<p> 讨论 Web 服务器时，会需要 stat 数据结构中的 st_mode 和 st_size 成员 </p>
<h4 id="st-mode-成员则编码了文件访问许可位-Linux-在-sys-stat-h-中定义了宏谓词来确定-st-mode-成员-的文件类型："><a href="#st-mode-成员则编码了文件访问许可位-Linux-在-sys-stat-h-中定义了宏谓词来确定-st-mode-成员-的文件类型：" class="headerlink" title="st_mode 成员则编码了文件访问许可位 , Linux 在 sys/stat.h 中定义了宏谓词来确定 st_mode 成员 的文件类型："></a>st_mode 成员则编码了文件访问许可位 , Linux 在 sys/stat.h 中定义了宏谓词来确定 st_mode 成员 的文件类型：</h4><p> S_ISREG(m)。这是一个普通文件吗？ </p>
<p>S_ISDIR(m)0 这是一个目录文件吗？ </p>
<p>S _ISSOCK(m)。这是一个网络套接字吗？ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"> int main (int axgc, char **argv)</span><br><span class="line"> &#123;</span><br><span class="line">	 struct stat stat;</span><br><span class="line"> 	char *type, *readok;</span><br><span class="line"> 	Stat(argv[l], festat);</span><br><span class="line">    if (S ISREG(stat.st_mode)) /* Determine file type */</span><br><span class="line"> 		type = &quot;regular&quot;;</span><br><span class="line">	else if (S_ISDIR(stat.st_mode))</span><br><span class="line"> 		type = &quot;directory&quot;;</span><br><span class="line">	 else</span><br><span class="line"> 		type = &quot;other&quot;;</span><br><span class="line"> 	if ((stat.st_mode &amp; S_IRUSR))/* Check read access */</span><br><span class="line"> 		readok = &quot;yes&quot;;</span><br><span class="line"> 	else</span><br><span class="line"> 		readok = &quot;no&quot;;</span><br><span class="line"> 	printf(&quot;type: %s, read: %s\nM, type, readok);</span><br><span class="line"> 	exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="读-取-目-录-内-容"><a href="#读-取-目-录-内-容" class="headerlink" title="读 取 目 录 内 容 :"></a>读 取 目 录 内 容 :</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIR *opendir(const char *name);</span><br><span class="line">		返 回：若 成 功 ，则 为 处 理 的 指 针；若 出 错，则 为 NULL。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 函数 opendir 以路径名为参数，返回指向目录流的指针。流是对 条目有序列表的抽象，在这里是指目录项的列表。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct dirent *readdir(DIR *dirp);</span><br><span class="line">		返 回： 若 成 功 ，则 为 指 向 下 一 个 目 录 项 的 指 针；若 没 有 更 多 的 目 录 项 或 出 错，则 为 NULL。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 每次对 readdir 的调用返回的都是指向流 dirp 中下一个目录项的指针，或者，如果 没有更多目录项则返回 NULL。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int closedir(DIR *dirp);</span><br><span class="line">			返回：成功为 0; 错误为一 1。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 函数 closedir 关闭流并释放其所有的资源。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">	DIR *streamp;</span><br><span class="line">	struct dirent *dep;</span><br><span class="line">	streamp = Opendir(argv[1])</span><br><span class="line">	errno = 0;</span><br><span class="line">	while ((dep = readdir(streamp)) != NULL)&#123;</span><br><span class="line">		printf(&quot;Found file: %s\n&quot;, dep-&gt;d name)</span><br><span class="line">	&#125;</span><br><span class="line">	if (errno != 0)</span><br><span class="line">		unix_error(&quot;readdir error&quot;);</span><br><span class="line">	Closedir(streamp)</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件 :"></a>共享文件 :</h1><h3 id="内核用三个相关的数据结构来表示打开的文件："><a href="#内核用三个相关的数据结构来表示打开的文件：" class="headerlink" title="内核用三个相关的数据结构来表示打开的文件："></a>内核用三个相关的数据结构来表示打开的文件：</h3><p> 描述符表。每个进程都有它独立的描述符表，它的表项是由进程 打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</p>
<p> 文件表。打开文件的集合是由一张文件表来表示的，所有的进程共享这 张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、 引用计数 (即当前指向该表项的描述符表项数），以及一个指向 v-node 表中 对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不 会删除这个文件表表项，直到它的引用计数为零。</p>
<p> v - node 表。同文件表一样，所有的进程共享这张 v - node 表。每个表 项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。  </p>
<h1 id="I-O-重定向"><a href="#I-O-重定向" class="headerlink" title="I/O 重定向 :"></a>I/O 重定向 :</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int dup2(int oldfd, int newfd);</span><br><span class="line">		返 回：若 成 功 则 为 非 负 的 描 述 符，若 出 错 则 为 一1。</span><br></pre></td></tr></table></figure>

<p> dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 new - fd以前的内容。如果 newfd 已经打开了，dup2会在复制 oldfd 之前关闭 newfd。  </p>
<h1 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O :"></a>标准 I/O :</h1><p> C 语言定义了一组高级输人输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代。这个库（libc)提供了打开和关闭文件的函数（fopen 和 fclose)、读 和写字节的函数（fread 和 fwrite)、读和写字符串的函数（fgets 和 fputs)，以及复杂 的格式化的 I/O 函数（scanf 和 printf)。</p>
<p>  标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指 向 FILE 类型的结构的指针。每个 ANSI C 程序开始时都有三个打开的流 stdin、stdout 和 stderr，分别对应于标准输人、标准输出和标准错误： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern FILE *stdin; /* Standard input(descriptor 0) /</span><br><span class="line">extern FILE *stdout; /* Standard output(descriptor 1)*/</span><br><span class="line">extern FILE *stderr; /* Standard error(descriptor 2)*/</span><br></pre></td></tr></table></figure>

<p> 类型为 FILE 的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和 RIO 读缓冲 区的一样：就是使开销较高的 Linux I/O 系统调用的数量尽可能得小。例如，假设我们有 一个程序，它反复调用标准 I/O 的 getc 函数，每次调用返回文件的下一个字符。当第一 次调用 getc 时，库通过调用一次 read 函数来填充流缓冲区，然后将缓冲区中的第一个 字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc 的调用就能直接从 流缓冲区得到服务。 </p>
<h1 id="我-该-使-用-哪-些-I-O-函-数-："><a href="#我-该-使-用-哪-些-I-O-函-数-：" class="headerlink" title="我 该 使 用 哪 些 I/O 函 数 ："></a>我 该 使 用 哪 些 I/O 函 数 ：</h1><p> 只要有可能就使用标准 I/O。  (stat 在标准 I/O 库中没有与它对应的函 数 )</p>
<p> 不要使用 scanf 或 rio_readlineb 来读二进制文件。  二进制文件可能散布着很多 Oxa 字节，而这些字节又与终止文本行无关。 </p>
<p> 对网络套接字的 I/O 使用 RIO 函数。 </p>
<p> 标准 I/O 流，从某种意义上而言是全双工的，因为程序能够在同一个流上执行输人和 输出。然而，对流的限制和对套接字的限制，有时候会互相冲突，而又极少有文档描述这 些现象：  </p>
<p> 限制一 ：跟在输出函数之后的输入函数。如果中间没有插人对 fflush、fseek、 fsetpos 或者 rewind 的调用，一个输人函数不能跟随在一个输出函数之后。 fflush 函数清空与流相关的缓冲区。后三个函数使用 Unix I/O lseek 函数来重置 当前的文件位置。</p>
<p>限制二：跟在输入函数之后的输出函数。如果中间没有插人对 fseek、 fsetpos 或 者 rewind 的调用，一个输出函数不能跟随在一个输人函数之后，除非该输入函数 遇到了一个文件结束。 </p>
<p> 这些限制给网络应用带来了一个问题，因为对套接字使用 lseek 函数是非法的。对流 I/O 的第一个限制能够通过采用在每个输人操作前刷新缓冲区这样的规则来满足。然而， 要满足第二个限制的唯一办法是，对同一个打开的套接字描述符打开两个流，一个用来 读，一个用来写 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fpin, *fpout;</span><br><span class="line">fpin = fdopen(sockfd, &quot;r&quot;);</span><br><span class="line">fpout = fdopen(sockfd, &quot;w&quot;):</span><br></pre></td></tr></table></figure>

<p> 这种方法也有问题，因为它要求应用程序在两个流上都要调用 fclose，这样才 能释放与每个流相关联的内存资源，避免内存泄漏： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclose(fpin);</span><br><span class="line">fclose(fpout)</span><br></pre></td></tr></table></figure>

<p> 这些操作中的每一个都试图关闭同一个底层的套接字描述符，所以第二个 close 操作 就会失败。 </p>
<p> 建议你在网络套接字上不要使用标准 I/O 函数来进行输人和输出，而要使 用健壮的 RIO 函数。如果你需要格式化的输出，使用 sprintf 函数在内存中格式化一个 字符串，然后用 rio_writen 把它发送到套接口。如果你需要格式化输人，使用 rio_ readlineb 来读一个完整的文本行，然后用 sscanf 从文本行提取不同的字段。 </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hexo/" rel="tag"># hexo</a>
              <a href="/tags/csapp/" rel="tag"># csapp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/04/PE%E8%A7%A3%E6%9E%90%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8F%B0/" rel="prev" title="PE解析器控制台">
      <i class="fa fa-chevron-left"></i> PE解析器控制台
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/10/%E5%8F%8D%E8%B0%83%E8%AF%95/" rel="next" title="反调试">
      反调试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0-Unix-I-O%E6%84%8F%E4%B9%89-%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">学习 Unix I&#x2F;O意义 ：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-Unix-I-O-%E5%B0%86%E5%B8%AE%E5%8A%A9%E4%BD%A0%E7%90%86%E8%A7%A3%E5%85%B6%E4%BB%96%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E3%80%82"><span class="nav-number">2.1.</span> <span class="nav-text">了解 Unix I&#x2F;O 将帮助你理解其他的系统概念。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%97%B6%E4%BD%A0%E9%99%A4%E4%BA%86%E4%BD%BF%E7%94%A8-Unix-I-O-%E4%BB%A5%E5%A4%96%E5%88%AB%E6%97%A0%E9%80%89%E6%8B%A9%E3%80%82"><span class="nav-number">2.2.</span> <span class="nav-text">有时你除了使用 Unix I&#x2F;O 以外别无选择。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unix-I-O-%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">Unix I&#x2F;O ：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84-I-O-%E8%AE%BE%E5%A4%87-%E4%BE%8B%E5%A6%82%E7%BD%91%E7%BB%9C%E3%80%81%E7%A3%81%E7%9B%98%E5%92%8C%E7%BB%88%E7%AB%AF-%E9%83%BD%E8%A2%AB%E6%A8%A1%E5%9E%8B%E5%8C%96%E4%B8%BA%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E6%89%80%E6%9C%89%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E9%83%BD%E8%A2%AB%E5%BD%93-%E4%BD%9C%E5%AF%B9%E7%9B%B8%E5%BA%94%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%92%8C%E5%86%99%E6%9D%A5%E6%89%A7%E8%A1%8C%E3%80%82%E8%BF%99%E7%A7%8D%E5%B0%86%E8%AE%BE%E5%A4%87%E4%BC%98%E9%9B%85%E5%9C%B0%E6%98%A0%E5%B0%84%E4%B8%BA%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%85%81%E8%AE%B8-Linux-%E5%86%85%E6%A0%B8%E5%BC%95-%E5%87%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E3%80%81%E4%BD%8E%E7%BA%A7%E7%9A%84%E5%BA%94%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%A7%B0%E4%B8%BA-Unix-I-O-%E8%BF%99%E4%BD%BF%E5%BE%97%E6%89%80%E6%9C%89%E7%9A%84%E8%BE%93%E4%BA%BA%E5%92%8C%E8%BE%93%E5%87%BA%E9%83%BD%E8%83%BD%E4%BB%A5%E4%B8%80%E7%A7%8D%E7%BB%9F-%E4%B8%80%E4%B8%94%E4%B8%80%E8%87%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%89%A7%E8%A1%8C%EF%BC%9A"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">所有的 I&#x2F;O 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I&#x2F;O, 这使得所有的输人和输出都能以一种统 一且一致的方式来执行：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">文件：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6-%EF%BC%9A-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">普通文件 ： 文本文件和二进制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">文本文件：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">4.1.2.</span> <span class="nav-text">二进制文件：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">目录：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6-%EF%BC%9A"><span class="nav-number">5.</span> <span class="nav-text">打开和关闭文件 ：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flags%EF%BC%9A"><span class="nav-number">5.0.1.</span> <span class="nav-text">flags：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mode-%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E4%BA%86%E6%96%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BD%8D"><span class="nav-number">5.0.2.</span> <span class="nav-text">mode 参数指定了新文件的访问权限位:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BB-%E5%92%8C-%E5%86%99-%E6%96%87-%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">读 和 写 文 件 :</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8-RIO-%E5%8C%85%E5%81%A5%E5%A3%AE%E5%9C%B0%E8%AF%BB%E5%86%99"><span class="nav-number">7.</span> <span class="nav-text">用 RIO 包健壮地读写:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%83%8F%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E8%BF%99%E6%A0%B7%E5%AE%B9%E6%98%93%E5%87%BA%E7%8E%B0%E4%B8%8D%E8%B6%B3%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD%EF%BC%8CRIO-%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E6%96%B9%E4%BE%BF%E3%80%81%E5%81%A5%E5%A3%AE%E5%92%8C%E9%AB%98%E6%95%88%E7%9A%84-I-O%E3%80%82RIO-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%A4%E7%B1%BB%E4%B8%8D%E5%90%8C%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">7.0.1.</span> <span class="nav-text">像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I&#x2F;O。RIO 提供了两类不同的函数：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIO-%E7%9A%84%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0-%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">RIO 的无缓冲的输入输出函数 ：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIO-%E7%9A%84%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">RIO 的带缓冲的输入函数 :</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BB-%E5%8F%96-%E6%96%87-%E4%BB%B6-%E5%85%83-%E6%95%B0-%E6%8D%AE"><span class="nav-number">8.</span> <span class="nav-text">读 取 文 件 元 数 据 :</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#st-mode-%E6%88%90%E5%91%98%E5%88%99%E7%BC%96%E7%A0%81%E4%BA%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E8%AE%B8%E5%8F%AF%E4%BD%8D-Linux-%E5%9C%A8-sys-stat-h-%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E5%AE%8F%E8%B0%93%E8%AF%8D%E6%9D%A5%E7%A1%AE%E5%AE%9A-st-mode-%E6%88%90%E5%91%98-%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">8.0.0.1.</span> <span class="nav-text">st_mode 成员则编码了文件访问许可位 , Linux 在 sys&#x2F;stat.h 中定义了宏谓词来确定 st_mode 成员 的文件类型：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BB-%E5%8F%96-%E7%9B%AE-%E5%BD%95-%E5%86%85-%E5%AE%B9"><span class="nav-number">9.</span> <span class="nav-text">读 取 目 录 内 容 :</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="nav-number">10.</span> <span class="nav-text">共享文件 :</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%94%A8%E4%B8%89%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E8%A1%A8%E7%A4%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">10.0.1.</span> <span class="nav-text">内核用三个相关的数据结构来表示打开的文件：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">11.</span> <span class="nav-text">I&#x2F;O 重定向 :</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86-I-O"><span class="nav-number">12.</span> <span class="nav-text">标准 I&#x2F;O :</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%88%91-%E8%AF%A5-%E4%BD%BF-%E7%94%A8-%E5%93%AA-%E4%BA%9B-I-O-%E5%87%BD-%E6%95%B0-%EF%BC%9A"><span class="nav-number">13.</span> <span class="nav-text">我 该 使 用 哪 些 I&#x2F;O 函 数 ：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LSC"
      src="/images/5.jpg">
  <p class="site-author-name" itemprop="name">LSC</p>
  <div class="site-description" itemprop="description">个人技术分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LSC</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
